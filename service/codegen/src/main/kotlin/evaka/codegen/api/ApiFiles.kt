// SPDX-FileCopyrightText: 2017-2022 City of Espoo
//
// SPDX-License-Identifier: LGPL-2.1-or-later

package evaka.codegen.api

import evaka.codegen.fileHeader
import kotlin.reflect.KClass
import kotlin.reflect.jvm.jvmName
import mu.KotlinLogging

private val logger = KotlinLogging.logger {}

fun generateApiFiles(): Map<TsFile, String> {
    val endpoints =
        scanEndpoints("fi.espoo.evaka")
            .filter { it.isJsonEndpoint }
            .filterNot { it.path.startsWith("/integration") }
    endpoints.forEach { it.validate() }

    val metadata =
        discoverMetadata(
            initial = defaultMetadata,
            rootTypes = endpoints.asSequence().flatMap { it.types() } + forceIncludes.asSequence()
        )

    val groups = metadata.namedTypes().groupBy { getBasePackage(it.clazz) }

    val tsCodeGenerator =
        object : TsCodeGenerator(metadata) {
            override fun locateNamedType(namedType: TsNamedType): TsFile =
                getBasePackage(namedType.clazz).let { pkg ->
                    TsProject.LibCommon / "generated/api-types/$pkg.ts"
                }
        }

    return groups
        .map { (mainPackage, namedTypes) ->
            val file = TsProject.LibCommon / "generated/api-types/$mainPackage.ts"
            file to render(file, tsCodeGenerator, namedTypes.sortedBy { it.name })
        }
        .toMap()
}

fun render(file: TsFile, generator: TsCodeGenerator, namedTypes: Collection<TsNamedType>): String {
    val conflicts = namedTypes.groupBy { it.name }.filter { it.value.size > 1 }
    conflicts.forEach { (name, conflictingClasses) ->
        logger.error("Multiple Kotlin classes map to $name: ${conflictingClasses.map { it.name }}")
    }
    if (conflicts.isNotEmpty()) {
        error("${conflicts.size} classes are generated by more than one Kotlin class")
    }
    val tsNamedTypes = namedTypes.map { generator.namedType(it) }
    val deserializers = namedTypes.mapNotNull { generator.jsonDeserializer(it) }
    val imports =
        tsNamedTypes.flatMap { it.imports }.toSet() + deserializers.flatMap { it.imports }.toSet()
    val sections =
        listOf(generateImports(file, imports)) +
            tsNamedTypes.map { it.text } +
            deserializers.map { it.text }
    return """$fileHeader
${sections.filter { it.isNotBlank() }.joinToString("\n\n")}
"""
        .lineSequence()
        .map { it.trimEnd() }
        .joinToString("\n")
}

fun generateImports(currentFile: TsFile, imports: Iterable<TsImport>): String =
    imports
        .filterNot { it.file == currentFile }
        .sortedWith(compareBy({ it is TsImport.Named }, { it.name }))
        .joinToString("\n") { import ->
            val path = import.file.importFrom(currentFile)
            when (import) {
                is TsImport.Default -> "import ${import.name} from '$path'"
                is TsImport.NamedAs ->
                    "import { ${import.originalName} as ${import.name} } from '$path'"
                is TsImport.Named -> "import { ${import.name} } from '$path'"
            }
        }

private fun getBasePackage(clazz: KClass<*>): String {
    val pkg = clazz.jvmName.substringBeforeLast('.')
    val relativePackage =
        when {
            pkg == basePackage -> return "base"
            pkg.startsWith("$basePackage.") -> pkg.substring(basePackage.length + 1)
            else -> error("class not under base package")
        }
    return relativePackage.substringBefore('.')
}
